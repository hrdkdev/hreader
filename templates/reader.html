<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ book.metadata.title }}</title>
    <style>
        /* Layout */
        body { margin: 0; padding: 0; display: flex; height: 100vh; overflow: hidden; font-family: "Georgia", serif; background: #fff; }

        /* Sidebar */
        #sidebar { width: 300px; background: #f8f9fa; border-right: 1px solid #e9ecef; overflow-y: auto; padding: 20px; flex-shrink: 0; }
        .nav-header { font-family: -apple-system, sans-serif; font-weight: bold; color: #495057; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #dee2e6; }
        .nav-home { display: block; margin-bottom: 20px; color: #3498db; text-decoration: none; font-family: -apple-system, sans-serif; font-size: 0.9em; }

        /* TOC Tree */
        ul.toc-list { list-style: none; padding-left: 0; margin: 0; }
        ul.toc-list ul { padding-left: 20px; } /* Indent children */
        li.toc-item { margin-bottom: 8px; }
        a.toc-link { text-decoration: none; color: #495057; font-size: 0.95em; display: block; padding: 4px 0; line-height: 1.4; }
        a.toc-link:hover { color: #000; text-decoration: underline; }
        a.toc-link.active { color: #d63384; font-weight: bold; }

        /* Main Content */
        #main { flex-grow: 1; overflow-y: auto; position: relative; scroll-behavior: smooth; }
        .content-container { max-width: 700px; margin: 0 auto; padding: 60px 40px; line-height: 1.8; font-size: 1.15em; color: #212529; }

        /* Content Styling (Basic normalization for the book HTML) */
        .book-content img { max-width: 100%; height: auto; display: block; margin: 20px auto; }
        .book-content h1, .book-content h2, .book-content h3 { font-family: -apple-system, sans-serif; margin-top: 1.5em; color: #333; }
        .book-content p { margin-bottom: 1.5em; text-align: justify; }

        /* Navigation Footer */
        .chapter-nav { display: flex; justify-content: space-between; margin-top: 60px; padding-top: 20px; border-top: 1px solid #eee; font-family: -apple-system, sans-serif; }
        .nav-btn { text-decoration: none; color: #3498db; font-weight: bold; padding: 10px 20px; border: 1px solid #3498db; border-radius: 4px; transition: all 0.2s; }
        .nav-btn:hover { background: #3498db; color: white; }
        .nav-btn.disabled { opacity: 0.5; pointer-events: none; border-color: #ccc; color: #ccc; }

        /* Highlighter Styles */
        .highlight { background-color: #ffeb3b; border-radius: 2px; padding: 1px 2px; transition: background-color 0.2s ease; }
        .highlight:hover { background-color: #fdd835; }
        
        /* Highlight Selection UI */
        .highlight-toolbar { position: absolute; background: #2c3e50; border-radius: 6px; padding: 8px 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; display: none; font-family: -apple-system, sans-serif; }
        .highlight-btn { background: none; border: none; color: white; padding: 6px 12px; margin: 0 2px; border-radius: 4px; cursor: pointer; font-size: 14px; transition: background-color 0.2s; }
        .highlight-btn:hover { background-color: rgba(255,255,255,0.1); }
        .highlight-btn:first-child { background-color: #ffeb3b; color: #333; }
        .highlight-btn:first-child:hover { background-color: #fdd835; }

        /* Audio Player Styles */
        #audio-player {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: #1a1a2e;
            border-top: 1px solid #333;
            display: none;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
            font-family: -apple-system, sans-serif;
            z-index: 1001;
        }
        #audio-player.visible { display: flex; }
        
        /* Adjust main content when player is visible */
        body.has-audio-player #main { padding-bottom: 60px; }
        
        .audio-btn {
            background: none;
            border: none;
            color: #fff;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        .audio-btn:hover { background: rgba(255,255,255,0.1); }
        .audio-btn svg { width: 24px; height: 24px; fill: currentColor; }
        
        .play-btn {
            background: #fff;
            color: #1a1a2e;
            width: 40px;
            height: 40px;
        }
        .play-btn:hover { background: #e0e0e0; }
        
        .audio-progress-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .audio-time {
            color: #aaa;
            font-size: 12px;
            min-width: 45px;
            text-align: center;
        }
        
        .audio-progress-bar {
            flex: 1;
            height: 4px;
            background: #444;
            border-radius: 2px;
            cursor: pointer;
            position: relative;
        }
        .audio-progress-bar:hover { height: 6px; }
        
        .audio-progress-fill {
            height: 100%;
            background: #fff;
            border-radius: 2px;
            width: 0%;
            position: relative;
        }
        .audio-progress-fill::after {
            content: '';
            position: absolute;
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .audio-progress-bar:hover .audio-progress-fill::after { opacity: 1; }
        
        .audio-speed-btn {
            color: #aaa;
            font-size: 12px;
            padding: 4px 8px;
            border: 1px solid #444;
            border-radius: 4px;
            background: none;
            cursor: pointer;
            min-width: 45px;
        }
        .audio-speed-btn:hover { border-color: #666; color: #fff; }
        
        .audio-chapter-container {
            display: none;
            align-items: center;
            gap: 8px;
        }
        
        .audio-chapter-select {
            background: #2a2a3e;
            color: #fff;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            max-width: 200px;
            cursor: pointer;
        }
        .audio-chapter-select:hover { border-color: #666; }
        
        .audio-chapter-info {
            color: #aaa;
            font-size: 11px;
            min-width: 40px;
        }
        
        .audio-nav-btn {
            background: none;
            border: none;
            color: #aaa;
            cursor: pointer;
            padding: 6px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .audio-nav-btn:hover { color: #fff; background: rgba(255,255,255,0.1); }
        .audio-nav-btn svg { width: 18px; height: 18px; fill: currentColor; }
        
        .audio-volume-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .audio-volume-slider {
            width: 80px;
            height: 4px;
            -webkit-appearance: none;
            background: #444;
            border-radius: 2px;
            cursor: pointer;
        }
        .audio-volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }
        .audio-volume-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

    </style>
</head>
<body>

    <!-- SIDEBAR -->
    <div id="sidebar">
        <a href="/" class="nav-home">← Back to Library</a>
        <div class="nav-header">{{ book.metadata.title }}</div>

        <!-- Recursive Macro for TOC -->
        {% macro render_toc(items) %}
            <ul class="toc-list">
            {% for item in items %}
                <li class="toc-item">
                    <!--
                        Matching Logic:
                        If the TOC item filename matches the current chapter filename, mark active.
                        Ideally we match spine indices, but Reader 3 TOC maps to filenames.
                        We use a simple hash matching logic here.
                    -->
                    {% set is_active = current_chapter.href == item.file_href %}

                    <!--
                       We need to find which linear chapter index (0, 1, 2) corresponds
                       to this TOC entry file.
                       Since that's hard to calculate in Jinja, we just link to the
                       file anchor. BUT, to make our linear navigation work, we
                       rely on the fact that the user is currently reading 'chapter_index'.

                       Ideally, clicking a TOC link should find the 'index' of that file.
                       For simplicity in this version: We link to the 'href' (filename)
                       and let JavaScript or Backend handle it?

                       Actually, let's just link to the file. The browser interprets #anchors.
                       However, our router uses /read/book/INDEX.

                       SIMPLE FIX: We won't link the TOC to the route index in this simple version
                       unless we build a map. We will visually show structure,
                       but rely on "Previous/Next" for linear reading.

                       BETTER FIX: Use JavaScript to match filenames.
                    -->
                    <a href="#" onclick="findAndGo('{{ item.file_href }}')"
                       class="toc-link {% if is_active %}active{% endif %}">
                        {{ item.title }}
                    </a>

                    {% if item.children %}
                        {{ render_toc(item.children) }}
                    {% endif %}
                </li>
            {% endfor %}
            </ul>
        {% endmacro %}

        {{ render_toc(book.toc) }}
    </div>

    <!-- MAIN CONTENT -->
    <div id="main">
        <div class="content-container">
            <div class="book-content">
                {{ current_chapter.content | safe }}
            </div>

            <div class="chapter-nav">
                {% if prev_idx is not none %}
                    <a href="/read/{{ book_id | urlencode }}/{{ prev_idx }}" class="nav-btn">← Previous</a>
                {% else %}
                    <span class="nav-btn disabled">← Previous</span>
                {% endif %}

                <span style="color: #999; padding: 10px;">
                    Section {{ chapter_index + 1 }} of {{ book.spine|length }}
                </span>

                {% if next_idx is not none %}
                    <a href="/read/{{ book_id | urlencode }}/{{ next_idx }}" class="nav-btn">Next →</a>
                {% else %}
                    <span class="nav-btn disabled">Next →</span>
                {% endif %}
            </div>
        </div>
    </div>

    <!-- AUDIO PLAYER -->
    <div id="audio-player">
        <audio id="audio-element" preload="metadata"></audio>
        
        <!-- Previous Chapter Button -->
        <button class="audio-nav-btn" id="prev-chapter-btn" title="Previous Chapter ([)">
            <svg viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg>
        </button>
        
        <!-- Play/Pause Button -->
        <button class="audio-btn play-btn" id="play-pause-btn" title="Play/Pause (Space)">
            <svg id="play-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
            <svg id="pause-icon" viewBox="0 0 24 24" style="display:none"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
        </button>
        
        <!-- Next Chapter Button -->
        <button class="audio-nav-btn" id="next-chapter-btn" title="Next Chapter (])">
            <svg viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>
        </button>
        
        <!-- Progress Section -->
        <div class="audio-progress-container">
            <span class="audio-time" id="current-time">0:00</span>
            <div class="audio-progress-bar" id="progress-bar">
                <div class="audio-progress-fill" id="progress-fill"></div>
            </div>
            <span class="audio-time" id="duration">0:00</span>
        </div>
        
        <!-- Chapter Selector (shown for multi-file audiobooks) -->
        <div class="audio-chapter-container" id="chapter-container">
            <span class="audio-chapter-info" id="chapter-info">1/1</span>
            <select class="audio-chapter-select" id="chapter-select" title="Select Chapter"></select>
        </div>
        
        <!-- Speed Control -->
        <button class="audio-speed-btn" id="speed-btn" title="Playback Speed">1x</button>
        
        <!-- Volume Control -->
        <div class="audio-volume-container">
            <button class="audio-btn" id="volume-btn" title="Mute/Unmute">
                <svg id="volume-icon" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
                <svg id="mute-icon" viewBox="0 0 24 24" style="display:none"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>
            </button>
            <input type="range" class="audio-volume-slider" id="volume-slider" min="0" max="1" step="0.1" value="1">
        </div>
    </div>

    <script>
        // Helper to map TOC filenames to Spine Indices
        // Pass the spine data from python to JS
        const spineMap = {
            {% for ch in book.spine %}
            "{{ ch.href }}": {{ ch.order }},
            {% endfor %}
        };

        function findAndGo(filename) {
            // The TOC usually has specific filenames e.g. "text/part001.html"
            // Sometimes it has anchors "text/part001.html#header"
            // We strip the anchor to find the page index
            const cleanFile = filename.split('#')[0];
            const anchor = filename.split('#')[1];

            const idx = spineMap[cleanFile];

            if (idx !== undefined) {
                let url = "/read/{{ book_id | urlencode }}/" + idx;
                // If there was an anchor, we could try to scroll to it,
                // but simple page loads often lose anchor position without extra JS.
                // Let's just go to the page.
                window.location.href = url;
            } else {
                console.log("Could not find index for", filename);
            }
        }

        // Highlighter functionality
        let highlightToolbar = null;
        let selectedRange = null;

        // Initialize highlighter when page loads
        document.addEventListener('DOMContentLoaded', function() {
            const bookContent = document.querySelector('.book-content');
            
            // Create highlight toolbar
            highlightToolbar = document.createElement('div');
            highlightToolbar.className = 'highlight-toolbar';
            highlightToolbar.innerHTML = `
                <button class="highlight-btn" onclick="highlightSelection()">Highlight</button>
                <button class="highlight-btn" onclick="removeHighlight()">Remove</button>
            `;
            document.body.appendChild(highlightToolbar);

            // Listen for text selection
            bookContent.addEventListener('mouseup', handleTextSelection);
            bookContent.addEventListener('touchend', handleTextSelection);
            document.addEventListener('selectionchange', handleSelectionChange);

            // Hide toolbar when clicking elsewhere
            document.addEventListener('mousedown', function(e) {
                if (!highlightToolbar.contains(e.target)) {
                    hideToolbar();
                }
            });
        });

        function handleTextSelection() {
            setTimeout(() => {
                const selection = window.getSelection();
                if (selection.rangeCount > 0 && !selection.isCollapsed) {
                    const range = selection.getRangeAt(0);
                    const text = selection.toString().trim();
                    
                    if (text.length > 0) {
                        selectedRange = range.cloneRange();
                        showToolbar(range);
                    } else {
                        hideToolbar();
                    }
                } else {
                    hideToolbar();
                }
            }, 10);
        }

        function handleSelectionChange() {
            const selection = window.getSelection();
            if (selection.isCollapsed || selection.toString().trim() === '') {
                hideToolbar();
            }
        }

        function showToolbar(range) {
            const rect = range.getBoundingClientRect();
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            
            // Position toolbar above the selection
            let top = rect.top + scrollTop - 50;
            let left = rect.left + scrollLeft + (rect.width / 2) - 60;
            
            // Keep toolbar within viewport
            if (top < scrollTop + 10) top = rect.bottom + scrollTop + 10;
            if (left < scrollLeft + 10) left = scrollLeft + 10;
            if (left + 120 > scrollLeft + window.innerWidth - 10) {
                left = scrollLeft + window.innerWidth - 130;
            }
            
            highlightToolbar.style.top = top + 'px';
            highlightToolbar.style.left = left + 'px';
            highlightToolbar.style.display = 'block';
        }

        function hideToolbar() {
            highlightToolbar.style.display = 'none';
            selectedRange = null;
        }

        function highlightSelection() {
            if (!selectedRange) return;
            
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;
            
            const range = selection.getRangeAt(0);
            const text = selection.toString().trim();
            
            // Check if selection is already highlighted
            if (isHighlighted(range)) {
                removeHighlight();
                return;
            }
            
            // IMPORTANT: Calculate offset BEFORE modifying the DOM
            const bookContent = document.querySelector('.book-content');
            const startOffset = calculateRangeOffset(bookContent, range);
            
            if (startOffset === -1) {
                console.error('Failed to calculate offset for selection');
                return;
            }
            
            // Create unique ID for this highlight
            const highlightId = 'highlight_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            // Create highlight span
            const highlightSpan = document.createElement('span');
            highlightSpan.className = 'highlight';
            highlightSpan.id = highlightId;
            
            try {
                // Surround the selection with highlight
                range.surroundContents(highlightSpan);
                
                // Save highlight to backend with pre-calculated offset
                saveHighlight(highlightId, text, startOffset)
                    .then(() => {
                        // Clear selection and hide toolbar
                        selection.removeAllRanges();
                        hideToolbar();
                        console.log('Highlight saved:', text);
                    })
                    .catch(error => {
                        console.error('Failed to save highlight:', error);
                        // Remove highlight from DOM if save failed
                        const parent = highlightSpan.parentNode;
                        while (highlightSpan.firstChild) {
                            parent.insertBefore(highlightSpan.firstChild, highlightSpan);
                        }
                        parent.removeChild(highlightSpan);
                    });
                    
            } catch (error) {
                console.error('Failed to create highlight:', error);
                // Fallback for complex selections
                const contents = range.extractContents();
                highlightSpan.appendChild(contents);
                range.insertNode(highlightSpan);
                
                // Try to save the fallback highlight
                saveHighlight(highlightId, text, startOffset)
                    .catch(err => console.error('Failed to save fallback highlight:', err));
            }
        }

        function removeHighlight() {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;
            
            const range = selection.getRangeAt(0);
            
            // Find highlighted parent elements
            const highlightedElements = getHighlightedElements(range);
            
            if (highlightedElements.length === 0) {
                hideToolbar();
                return;
            }
            
            // Get highlight IDs and remove from backend
            const removePromises = highlightedElements.map(element => {
                const highlightId = element.id;
                if (highlightId && highlightId.startsWith('highlight_')) {
                    return deleteHighlight(highlightId).catch(err => 
                        console.error('Failed to delete highlight from backend:', err)
                    );
                }
                return Promise.resolve();
            });
            
            Promise.all(removePromises).then(() => {
                // Remove highlights from DOM
                highlightedElements.forEach(element => {
                    const parent = element.parentNode;
                    while (element.firstChild) {
                        parent.insertBefore(element.firstChild, element);
                    }
                    parent.removeChild(element);
                });
                
                // Clear selection and hide toolbar
                selection.removeAllRanges();
                hideToolbar();
                console.log('Highlights removed');
            });
        }

        function isHighlighted(range) {
            const container = range.commonAncestorContainer;
            const elements = container.querySelectorAll ? 
                           container.querySelectorAll('.highlight') : 
                           [];
            
            return Array.from(elements).some(el => 
                range.intersectsNode(el)
            );
        }

        function getHighlightedElements(range) {
            const container = range.commonAncestorContainer;
            const elements = container.querySelectorAll ? 
                           container.querySelectorAll('.highlight') : 
                           [];
            
            return Array.from(elements).filter(el => 
                range.intersectsNode(el)
            );
        }

        // Calculate the character offset of a range's start position within a container
        function calculateRangeOffset(container, range) {
            const walker = document.createTreeWalker(
                container,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let currentOffset = 0;
            let node;
            
            // Walk through all text nodes until we find the start of our range
            while (node = walker.nextNode()) {
                if (node === range.startContainer) {
                    // Found the start node - add the offset within this node
                    return currentOffset + range.startOffset;
                }
                // Add this node's length to the running offset
                currentOffset += node.textContent.length;
            }
            
            return -1; // Not found
        }

        // Backend communication functions
        async function saveHighlight(highlightId, text, startOffset) {
            const bookId = '{{ book_id | safe }}';
            const chapterIndex = {{ chapter_index }};
            
            console.log(`Saving highlight to book ${bookId}, chapter ${chapterIndex}`);
            console.log(`Text: "${text}", Start offset: ${startOffset}, End offset: ${startOffset + text.length}`);
            
            const highlightData = {
                book_id: bookId,
                highlight: {
                    id: highlightId,
                    chapter_index: chapterIndex,
                    text: text,
                    start_offset: startOffset,
                    end_offset: startOffset + text.length,
                    created_at: new Date().toISOString()
                }
            };
            
            const response = await fetch('/api/highlights', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(highlightData)
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            return response.json();
        }

        async function deleteHighlight(highlightId) {
            const bookId = '{{ book_id | safe }}';
            const chapterIndex = {{ chapter_index }};
            
            console.log(`Deleting highlight ${highlightId} from book ${bookId}, chapter ${chapterIndex}`);
            
            const requestData = {
                book_id: bookId,
                chapter_index: chapterIndex,
                highlight_id: highlightId
            };
            
            const response = await fetch('/api/highlights', {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestData)
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            return response.json();
        }

        async function loadChapterHighlights() {
            const bookId = '{{ book_id | safe }}';
            const chapterIndex = {{ chapter_index }};
            
            console.log(`Loading highlights for book ${bookId}, chapter ${chapterIndex}`);
            
            try {
                const response = await fetch(`/api/highlights/${encodeURIComponent(bookId)}/${chapterIndex}`);
                if (response.ok) {
                    const data = await response.json();
                    const highlights = data.highlights || [];
                    console.log(`Loaded ${highlights.length} highlights for chapter ${chapterIndex} of book ${bookId}`);
                    return highlights;
                }
            } catch (error) {
                console.error('Error loading highlights:', error);
            }
            
            return [];
        }

        // Restore highlights when page loads
        async function restoreHighlights() {
            console.log('Starting highlight restoration...');
            const highlights = await loadChapterHighlights();
            const bookContent = document.querySelector('.book-content');
            
            if (!bookContent) {
                console.error('Book content not found - .book-content element missing');
                return;
            }
            
            console.log(`Found book content with ${bookContent.children.length} children`);
            
            // Remove any existing highlights with the same IDs to avoid duplicates
            highlights.forEach(highlight => {
                const existingElement = document.getElementById(highlight.id);
                if (existingElement) {
                    const parent = existingElement.parentNode;
                    while (existingElement.firstChild) {
                        parent.insertBefore(existingElement.firstChild, existingElement);
                    }
                    parent.removeChild(existingElement);
                }
            });
            
            // Restore highlights with better text matching
            highlights.forEach((highlight, index) => {
                try {
                    console.log(`Attempting to restore highlight ${highlight.id}: "${highlight.text}"`);
                    const success = restoreHighlightWithOffset(bookContent, highlight);
                    if (!success) {
                        console.warn(`Failed to restore highlight ${highlight.id}: "${highlight.text}"`);
                        console.debug('Highlight data:', highlight);
                    } else {
                        console.log(`✓ Successfully restored highlight ${highlight.id}`);
                    }
                } catch (error) {
                    console.error('Error restoring highlight:', error);
                    console.debug('Failed highlight data:', highlight);
                }
            });
        }

        function restoreHighlightWithOffset(container, highlight) {
            const text = highlight.text;
            
            // First try offset-based restoration for accuracy
            const offsetSuccess = restoreByOffset(container, highlight);
            if (offsetSuccess) {
                console.log(`Successfully restored highlight ${highlight.id} using offset`);
                return true;
            }
            
            // Fallback to text-based search
            console.log(`Offset restoration failed for ${highlight.id}, trying text search`);
            return restoreByTextSearch(container, highlight);
        }

        function restoreByOffset(container, highlight) {
            const text = highlight.text;
            const targetOffset = highlight.start_offset;
            const endOffset = highlight.end_offset;
            const highlightLength = endOffset - targetOffset;
            
            // Walk through all text nodes and track character positions
            const walker = document.createTreeWalker(
                container,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let currentOffset = 0;
            let startNode = null;
            let startNodeOffset = 0;
            let endNode = null;
            let endNodeOffset = 0;
            
            // Collect all text nodes and find start/end positions
            const textNodes = [];
            let node;
            while (node = walker.nextNode()) {
                const nodeText = node.textContent;
                const nodeLength = nodeText.length;
                
                textNodes.push({
                    node: node,
                    startOffset: currentOffset,
                    endOffset: currentOffset + nodeLength,
                    text: nodeText
                });
                
                // Check if this node contains the start of our highlight
                if (!startNode && currentOffset <= targetOffset && currentOffset + nodeLength > targetOffset) {
                    startNode = node;
                    startNodeOffset = targetOffset - currentOffset;
                }
                
                // Check if this node contains the end of our highlight
                if (!endNode && currentOffset < endOffset && currentOffset + nodeLength >= endOffset) {
                    endNode = node;
                    endNodeOffset = endOffset - currentOffset;
                }
                
                currentOffset += nodeLength;
            }
            
            if (!startNode || !endNode) {
                console.log(`Could not find start/end nodes at offset ${targetOffset}-${endOffset}`);
                return false;
            }
            
            // Verify the text matches by collecting text from all nodes in the range
            let collectedText = '';
            let collecting = false;
            for (const nodeInfo of textNodes) {
                if (nodeInfo.node === startNode) {
                    collecting = true;
                    if (nodeInfo.node === endNode) {
                        // Same node for start and end
                        collectedText += nodeInfo.text.substring(startNodeOffset, endNodeOffset);
                        break;
                    } else {
                        collectedText += nodeInfo.text.substring(startNodeOffset);
                    }
                } else if (collecting) {
                    if (nodeInfo.node === endNode) {
                        collectedText += nodeInfo.text.substring(0, endNodeOffset);
                        break;
                    } else {
                        collectedText += nodeInfo.text;
                    }
                }
            }
            
            // Check if the collected text matches (with some tolerance for whitespace)
            const normalizedCollected = collectedText.replace(/\s+/g, ' ').trim();
            const normalizedTarget = text.replace(/\s+/g, ' ').trim();
            
            if (normalizedCollected !== normalizedTarget) {
                console.log(`Text mismatch at offset ${targetOffset}:`);
                console.log(`Expected: "${normalizedTarget}"`);
                console.log(`Found: "${normalizedCollected}"`);
                return false;
            }
            
            // Create highlight span
            const highlightSpan = document.createElement('span');
            highlightSpan.className = 'highlight';
            highlightSpan.id = highlight.id;
            
            // Handle single-node highlight
            if (startNode === endNode) {
                const nodeText = startNode.textContent;
                const before = nodeText.substring(0, startNodeOffset);
                const highlighted = nodeText.substring(startNodeOffset, endNodeOffset);
                const after = nodeText.substring(endNodeOffset);
                
                const parent = startNode.parentNode;
                
                if (before) {
                    parent.insertBefore(document.createTextNode(before), startNode);
                }
                
                highlightSpan.textContent = highlighted;
                parent.insertBefore(highlightSpan, startNode);
                
                if (after) {
                    parent.insertBefore(document.createTextNode(after), startNode);
                }
                
                parent.removeChild(startNode);
                return true;
            }
            
            // Handle multi-node highlight
            // We need to wrap the range in a highlight span
            // Create a range and use extractContents/surroundContents approach
            const range = document.createRange();
            range.setStart(startNode, startNodeOffset);
            range.setEnd(endNode, endNodeOffset);
            
            try {
                range.surroundContents(highlightSpan);
                return true;
            } catch (e) {
                // Fallback: extract contents and wrap
                const contents = range.extractContents();
                highlightSpan.appendChild(contents);
                range.insertNode(highlightSpan);
                return true;
            }
        }

        function restoreByTextSearch(container, highlight) {
            const text = highlight.text;
            
            // Walk through all text nodes and search for the text
            const walker = document.createTreeWalker(
                container,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            const textNodes = [];
            let node;
            while (node = walker.nextNode()) {
                textNodes.push(node);
            }
            
            // First, try to find exact match within a single node
            for (let i = 0; i < textNodes.length; i++) {
                const node = textNodes[i];
                const nodeText = node.textContent;
                const index = nodeText.indexOf(text);
                
                if (index !== -1) {
                    // Create highlight span
                    const highlightSpan = document.createElement('span');
                    highlightSpan.className = 'highlight';
                    highlightSpan.id = highlight.id;
                    
                    // Split the text node
                    const before = nodeText.substring(0, index);
                    const after = nodeText.substring(index + text.length);
                    
                    const parent = node.parentNode;
                    
                    // Insert before text
                    if (before) {
                        parent.insertBefore(document.createTextNode(before), node);
                    }
                    
                    // Insert highlight
                    highlightSpan.textContent = text;
                    parent.insertBefore(highlightSpan, node);
                    
                    // Insert after text
                    if (after) {
                        parent.insertBefore(document.createTextNode(after), node);
                    }
                    
                    // Remove original node
                    parent.removeChild(node);
                    
                    console.log(`Successfully restored highlight ${highlight.id} using text search (single node)`);
                    return true;
                }
            }
            
            // Try to find the text spanning multiple nodes
            const normalizedTarget = text.replace(/\s+/g, ' ').trim();
            
            for (let i = 0; i < textNodes.length; i++) {
                let collectedText = '';
                let startNode = null;
                let startOffset = 0;
                let endNode = null;
                let endOffset = 0;
                
                // Try to collect text starting from this node
                for (let j = i; j < textNodes.length; j++) {
                    const nodeText = textNodes[j].textContent;
                    
                    if (j === i) {
                        // First node - try different starting positions
                        for (let k = 0; k < nodeText.length; k++) {
                            const substring = nodeText.substring(k);
                            const testText = (collectedText + substring).replace(/\s+/g, ' ').trim();
                            
                            if (normalizedTarget.startsWith(testText)) {
                                if (testText === normalizedTarget) {
                                    // Found it within first node
                                    startNode = textNodes[j];
                                    startOffset = k;
                                    endNode = textNodes[j];
                                    endOffset = k + (nodeText.length - k);
                                    break;
                                }
                                // Potential match, continue collecting
                                startNode = textNodes[j];
                                startOffset = k;
                                collectedText = substring;
                                break;
                            }
                        }
                    } else if (startNode) {
                        // Continuing from previous nodes
                        collectedText += nodeText;
                        const testText = collectedText.replace(/\s+/g, ' ').trim();
                        
                        if (testText === normalizedTarget) {
                            endNode = textNodes[j];
                            endOffset = nodeText.length;
                            break;
                        } else if (!normalizedTarget.startsWith(testText)) {
                            // Overshot, reset
                            collectedText = '';
                            startNode = null;
                            break;
                        }
                    }
                }
                
                // If we found a match across nodes
                if (startNode && endNode && collectedText.replace(/\s+/g, ' ').trim() === normalizedTarget) {
                    const range = document.createRange();
                    range.setStart(startNode, startOffset);
                    range.setEnd(endNode, endOffset);
                    
                    const highlightSpan = document.createElement('span');
                    highlightSpan.className = 'highlight';
                    highlightSpan.id = highlight.id;
                    
                    try {
                        range.surroundContents(highlightSpan);
                        console.log(`Successfully restored highlight ${highlight.id} using text search (multi-node)`);
                        return true;
                    } catch (e) {
                        const contents = range.extractContents();
                        highlightSpan.appendChild(contents);
                        range.insertNode(highlightSpan);
                        console.log(`Successfully restored highlight ${highlight.id} using text search (multi-node fallback)`);
                        return true;
                    }
                }
            }
            
            // If exact text search fails, try with trimmed text
            const trimmedText = text.trim();
            if (trimmedText !== text && trimmedText.length > 0) {
                return restoreByTextSearch(container, {...highlight, text: trimmedText});
            }
            
            // If still fails, try with normalized whitespace
            const normalizedText = text.replace(/\s+/g, ' ').trim();
            if (normalizedText !== text && normalizedText.length > 0) {
                return restoreByTextSearch(container, {...highlight, text: normalizedText});
            }
            
            return false;
        }

        function highlightTextInContent(container, text, highlightId) {
            // Simple text highlighting - walks through text nodes and highlights matching text
            const walker = document.createTreeWalker(
                container,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            const textNodes = [];
            let node;
            while (node = walker.nextNode()) {
                textNodes.push(node);
            }
            
            // Find and highlight the text
            let found = false;
            for (let i = 0; i < textNodes.length && !found; i++) {
                const node = textNodes[i];
                const nodeText = node.textContent;
                const index = nodeText.indexOf(text);
                
                if (index !== -1) {
                    // Split the text node and insert highlight
                    const before = nodeText.substring(0, index);
                    const after = nodeText.substring(index + text.length);
                    
                    // Create highlight span
                    const highlightSpan = document.createElement('span');
                    highlightSpan.className = 'highlight';
                    highlightSpan.id = highlightId;
                    highlightSpan.textContent = text;
                    
                    // Replace the text node
                    const parent = node.parentNode;
                    if (before) {
                        parent.insertBefore(document.createTextNode(before), node);
                    }
                    parent.insertBefore(highlightSpan, node);
                    if (after) {
                        parent.insertBefore(document.createTextNode(after), node);
                    }
                    parent.removeChild(node);
                    
                    found = true;
                }
            }
        }

        // Call restoreHighlights when page loads with better timing
        document.addEventListener('DOMContentLoaded', function() {
            // Try to restore highlights with multiple delays
            setTimeout(restoreHighlights, 0);
            setTimeout(restoreHighlights, 100);
            setTimeout(restoreHighlights, 500);
            setTimeout(restoreHighlights, 1000);
            setTimeout(restoreHighlights, 2000);
        });

        // ============================================
        // READING PROGRESS AUTO-SAVE
        // ============================================
        
        const readingProgress = {
            bookId: '{{ book_id | safe }}',
            chapterIndex: {{ chapter_index }},
            scrollContainer: null,
            saveInterval: null,
            
            init: function() {
                // Get reference to scroll container
                this.scrollContainer = document.querySelector('#main');
                
                // Restore scroll position when opening a chapter
                this.restoreScrollPosition();
                
                // Save progress immediately when opening a chapter
                this.saveProgress();
                
                // Also save every 10 seconds while reading
                this.saveInterval = setInterval(() => {
                    this.saveProgress();
                }, 10000);
                
                // Save when navigating away
                window.addEventListener('beforeunload', () => this.saveProgress());
                
                console.log('Reading progress tracking initialized for chapter', this.chapterIndex);
            },
            
            async saveProgress() {
                try {
                    // Get current scroll position
                    const scrollTop = this.scrollContainer.scrollTop;
                    const scrollHeight = this.scrollContainer.scrollHeight;
                    const clientHeight = this.scrollContainer.clientHeight;
                    
                    // Calculate scroll percentage (0-1)
                    const maxScroll = scrollHeight - clientHeight;
                    const scrollPercentage = maxScroll > 0 ? scrollTop / maxScroll : 0;
                    
                    await fetch('/api/progress', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            book_id: this.bookId,
                            chapter_index: this.chapterIndex,
                            scroll_position: Math.round(scrollTop),
                            scroll_percentage: scrollPercentage
                        })
                    });
                } catch (error) {
                    console.error('Error saving reading progress:', error);
                }
            },
            
            async restoreScrollPosition() {
                try {
                    const response = await fetch(`/api/progress/${this.bookId}`);
                    const progress = await response.json();
                    
                    // Only restore if we're on the saved chapter
                    if (progress.current_chapter_index === this.chapterIndex) {
                        const scrollTop = progress.scroll_position || 0;
                        const scrollPercentage = progress.scroll_percentage || 0;
                        
                        // Wait for content to render
                        await new Promise(resolve => setTimeout(resolve, 50));
                        
                        // Try pixel-based first
                        if (scrollTop > 0) {
                            this.scrollContainer.scrollTo({
                                top: scrollTop,
                                behavior: 'smooth'
                            });
                        } else if (scrollPercentage > 0) {
                            // Fallback to percentage-based
                            const scrollHeight = this.scrollContainer.scrollHeight;
                            const clientHeight = this.scrollContainer.clientHeight;
                            const maxScroll = scrollHeight - clientHeight;
                            this.scrollContainer.scrollTo({
                                top: maxScroll * scrollPercentage,
                                behavior: 'smooth'
                            });
                        }
                    }
                } catch (error) {
                    console.error('Error restoring scroll position:', error);
                    // Fail silently - user starts at top
                }
            }
        };
        
        // Initialize reading progress when page loads
        document.addEventListener('DOMContentLoaded', function() {
            readingProgress.init();
        });

        // ============================================
        // AUDIO PLAYER FUNCTIONALITY
        // ============================================
        
        const audioPlayer = {
            element: null,
            playerUI: null,
            isPlaying: false,
            saveInterval: null,
            speedOptions: [0.5, 0.75, 1, 1.25, 1.5, 2],
            currentSpeedIndex: 2, // Default 1x
            bookId: null,
            
            // Multi-file audiobook support
            isMultiFile: false,
            chapters: [],
            currentChapterIndex: 0,
            
            init: function() {
                this.element = document.getElementById('audio-element');
                this.playerUI = document.getElementById('audio-player');
                this.bookId = '{{ book_id | safe }}';
                
                if (!this.element || !this.playerUI) return;
                
                // Check if audiobook is available for this book
                this.checkAudiobookAvailability();
            },
            
            async checkAudiobookAvailability() {
                try {
                    const response = await fetch(`/api/audio/${encodeURIComponent(this.bookId)}/metadata`);
                    const data = await response.json();
                    
                    if (data.available) {
                        console.log('Audiobook available:', data);
                        this.isMultiFile = data.is_multi_file || false;
                        this.chapters = data.chapters || [];
                        this.setupPlayer();
                    } else {
                        console.log('No audiobook available for this book');
                    }
                } catch (error) {
                    console.error('Error checking audiobook availability:', error);
                }
            },
            
            async setupPlayer() {
                // Show player UI
                this.playerUI.classList.add('visible');
                document.body.classList.add('has-audio-player');
                
                // Setup chapter selector if multi-file
                if (this.isMultiFile && this.chapters.length > 1) {
                    this.setupChapterSelector();
                }
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Load saved position (includes chapter index for multi-file)
                await this.loadSavedPosition();
                
                // Load the current chapter audio
                this.loadChapter(this.currentChapterIndex);
                
                // Start auto-save interval
                this.startAutoSave();
            },
            
            setupChapterSelector() {
                const chapterSelect = document.getElementById('chapter-select');
                const chapterContainer = document.getElementById('chapter-container');
                
                if (!chapterSelect || !chapterContainer) return;
                
                // Populate chapter options
                chapterSelect.innerHTML = this.chapters.map((ch, idx) => 
                    `<option value="${idx}">${ch.filename.replace('.m4b', '').replace('.M4B', '').replace('.mp3', '').replace('.MP3', '')}</option>`
                ).join('');
                
                // Show chapter selector
                chapterContainer.style.display = 'flex';
                
                // Handle chapter change
                chapterSelect.addEventListener('change', (e) => {
                    const wasPlaying = this.isPlaying;
                    this.loadChapter(parseInt(e.target.value));
                    if (wasPlaying) {
                        this.element.play();
                    }
                });
            },
            
            loadChapter(index) {
                if (index < 0 || index >= this.chapters.length) {
                    if (!this.isMultiFile) {
                        // Single file - just load it
                        this.element.src = `/api/audio/${encodeURIComponent(this.bookId)}`;
                        return;
                    }
                    return;
                }
                
                this.currentChapterIndex = index;
                
                if (this.isMultiFile) {
                    this.element.src = `/api/audio/${encodeURIComponent(this.bookId)}/${index}`;
                    
                    // Update chapter selector
                    const chapterSelect = document.getElementById('chapter-select');
                    if (chapterSelect) {
                        chapterSelect.value = index;
                    }
                    
                    // Update chapter display
                    const chapterInfo = document.getElementById('chapter-info');
                    if (chapterInfo) {
                        chapterInfo.textContent = `${index + 1}/${this.chapters.length}`;
                    }
                } else {
                    this.element.src = `/api/audio/${encodeURIComponent(this.bookId)}`;
                }
            },
            
            nextChapter() {
                if (this.currentChapterIndex < this.chapters.length - 1) {
                    const wasPlaying = this.isPlaying;
                    this.loadChapter(this.currentChapterIndex + 1);
                    if (wasPlaying) {
                        this.element.play();
                    }
                }
            },
            
            prevChapter() {
                // If more than 3 seconds into current chapter, restart it
                if (this.element.currentTime > 3) {
                    this.element.currentTime = 0;
                } else if (this.currentChapterIndex > 0) {
                    const wasPlaying = this.isPlaying;
                    this.loadChapter(this.currentChapterIndex - 1);
                    if (wasPlaying) {
                        this.element.play();
                    }
                }
            },
            
            setupEventListeners() {
                const audio = this.element;
                const playPauseBtn = document.getElementById('play-pause-btn');
                const playIcon = document.getElementById('play-icon');
                const pauseIcon = document.getElementById('pause-icon');
                const progressBar = document.getElementById('progress-bar');
                const progressFill = document.getElementById('progress-fill');
                const currentTimeEl = document.getElementById('current-time');
                const durationEl = document.getElementById('duration');
                const speedBtn = document.getElementById('speed-btn');
                const volumeBtn = document.getElementById('volume-btn');
                const volumeSlider = document.getElementById('volume-slider');
                const prevBtn = document.getElementById('prev-chapter-btn');
                const nextBtn = document.getElementById('next-chapter-btn');
                
                // Play/Pause button
                playPauseBtn.addEventListener('click', () => this.togglePlayPause());
                
                // Chapter navigation buttons
                if (prevBtn) prevBtn.addEventListener('click', () => this.prevChapter());
                if (nextBtn) nextBtn.addEventListener('click', () => this.nextChapter());
                
                // Audio events
                audio.addEventListener('play', () => {
                    this.isPlaying = true;
                    playIcon.style.display = 'none';
                    pauseIcon.style.display = 'block';
                });
                
                audio.addEventListener('pause', () => {
                    this.isPlaying = false;
                    playIcon.style.display = 'block';
                    pauseIcon.style.display = 'none';
                });
                
                audio.addEventListener('timeupdate', () => {
                    if (audio.duration) {
                        const percent = (audio.currentTime / audio.duration) * 100;
                        progressFill.style.width = percent + '%';
                        currentTimeEl.textContent = this.formatTime(audio.currentTime);
                    }
                });
                
                audio.addEventListener('loadedmetadata', () => {
                    durationEl.textContent = this.formatTime(audio.duration);
                });
                
                audio.addEventListener('durationchange', () => {
                    durationEl.textContent = this.formatTime(audio.duration);
                });
                
                // Auto-advance to next chapter when current one ends
                audio.addEventListener('ended', () => {
                    if (this.isMultiFile && this.currentChapterIndex < this.chapters.length - 1) {
                        this.loadChapter(this.currentChapterIndex + 1);
                        audio.play();
                    }
                });
                
                // Progress bar click to seek
                progressBar.addEventListener('click', (e) => {
                    const rect = progressBar.getBoundingClientRect();
                    const percent = (e.clientX - rect.left) / rect.width;
                    audio.currentTime = percent * audio.duration;
                });
                
                // Speed button
                speedBtn.addEventListener('click', () => this.cycleSpeed());
                
                // Volume controls
                volumeSlider.addEventListener('input', (e) => {
                    audio.volume = e.target.value;
                    this.updateVolumeIcon();
                });
                
                volumeBtn.addEventListener('click', () => {
                    audio.muted = !audio.muted;
                    this.updateVolumeIcon();
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Only handle if not typing in an input
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
                    
                    switch(e.code) {
                        case 'Space':
                            e.preventDefault();
                            this.togglePlayPause();
                            break;
                        case 'ArrowLeft':
                            if (e.shiftKey) {
                                audio.currentTime = Math.max(0, audio.currentTime - 30);
                            } else {
                                audio.currentTime = Math.max(0, audio.currentTime - 10);
                            }
                            break;
                        case 'ArrowRight':
                            if (e.shiftKey) {
                                audio.currentTime = Math.min(audio.duration, audio.currentTime + 30);
                            } else {
                                audio.currentTime = Math.min(audio.duration, audio.currentTime + 10);
                            }
                            break;
                        case 'ArrowUp':
                            e.preventDefault();
                            audio.volume = Math.min(1, audio.volume + 0.1);
                            volumeSlider.value = audio.volume;
                            this.updateVolumeIcon();
                            break;
                        case 'ArrowDown':
                            e.preventDefault();
                            audio.volume = Math.max(0, audio.volume - 0.1);
                            volumeSlider.value = audio.volume;
                            this.updateVolumeIcon();
                            break;
                        case 'BracketLeft':
                            // [ key - previous chapter
                            this.prevChapter();
                            break;
                        case 'BracketRight':
                            // ] key - next chapter
                            this.nextChapter();
                            break;
                    }
                });
            },
            
            togglePlayPause() {
                if (this.isPlaying) {
                    this.element.pause();
                } else {
                    this.element.play();
                }
            },
            
            cycleSpeed() {
                this.currentSpeedIndex = (this.currentSpeedIndex + 1) % this.speedOptions.length;
                const speed = this.speedOptions[this.currentSpeedIndex];
                this.element.playbackRate = speed;
                document.getElementById('speed-btn').textContent = speed + 'x';
            },
            
            updateVolumeIcon() {
                const volumeIcon = document.getElementById('volume-icon');
                const muteIcon = document.getElementById('mute-icon');
                
                if (this.element.muted || this.element.volume === 0) {
                    volumeIcon.style.display = 'none';
                    muteIcon.style.display = 'block';
                } else {
                    volumeIcon.style.display = 'block';
                    muteIcon.style.display = 'none';
                }
            },
            
            formatTime(seconds) {
                if (!seconds || isNaN(seconds)) return '0:00';
                
                const hours = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                
                if (hours > 0) {
                    return `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                }
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            },
            
            async loadSavedPosition() {
                try {
                    const response = await fetch(`/api/audio/${encodeURIComponent(this.bookId)}/position`);
                    const data = await response.json();
                    
                    // Restore chapter index for multi-file audiobooks
                    if (data.chapter_index !== undefined && this.isMultiFile) {
                        this.currentChapterIndex = data.chapter_index;
                    }
                    
                    // Position will be restored after audio loads
                    if (data.position && data.position > 0) {
                        this.pendingSeek = data.position;
                        this.element.addEventListener('loadedmetadata', () => {
                            if (this.pendingSeek) {
                                this.element.currentTime = this.pendingSeek;
                                console.log('Restored audio position:', this.formatTime(this.pendingSeek));
                                this.pendingSeek = null;
                            }
                        }, { once: true });
                    }
                } catch (error) {
                    console.error('Error loading saved position:', error);
                }
            },
            
            async savePosition() {
                if (!this.element.currentTime && !this.isMultiFile) return;
                
                try {
                    await fetch(`/api/audio/${encodeURIComponent(this.bookId)}/position`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            position: this.element.currentTime,
                            duration: this.element.duration || 0,
                            chapter_index: this.currentChapterIndex
                        })
                    });
                } catch (error) {
                    console.error('Error saving position:', error);
                }
            },
            
            startAutoSave() {
                // Save position every 5 seconds while playing
                this.saveInterval = setInterval(() => {
                    if (this.isPlaying) {
                        this.savePosition();
                    }
                }, 5000);
                
                // Also save on pause and when leaving page
                this.element.addEventListener('pause', () => this.savePosition());
                window.addEventListener('beforeunload', () => this.savePosition());
            }
        };
        
        // Initialize audio player when page loads
        document.addEventListener('DOMContentLoaded', function() {
            audioPlayer.init();
        });
    </script>
</body>
</html>
